# mysql执行流程

MySQL总体可以分为**Server层和存储引擎层**

Server层含有 **连接器**、**分析器**、**优化器**、**执行器**等

![image-20240712182126154](C:\Users\chenz\AppData\Roaming\Typora\typora-user-images\image-20240712182126154.png)

存储引擎个人理解是，存储的物理介质？支持InnoDB、MyISAM、Memory等多个存储引擎



## 建立连接

按照正常的使用流程

在使用之前，程序作为客户端首先需要通过**连接器**连接到MYSQL的数据库当中，即经典的

```bash
mysql -h$ip -P$port -u$user -p
```

输入后，客户端与服务器建立TCP连接，连接器确认身份，整个确认的过程可以分为以下多步：

1. TCP三次握手建立连接成功

2. 服务器向客户端发送**初始握手包**，其中包含服务器版本，认证数据等信息，（详见附）

3. 客户端向服务器发送响应响应包，其中包含**用户名 & 加密密码**，使用**sha1 & 盐值**进行加密

4. 服务器收到密码，在`mysql.user`表中查找对应的主机及用户名。并且将存储在数据库中的用户密码再次加密后与用户所发送的密码进行比较。（存储在服务器中的密码本身是经过加密后的，比较之时，需要再次进行加密）

5. 服务器比较后，根据验证情况返回：

   - 用户名密码**错误**：返回错误**"Access denied for user"** ，客户端程序结束执行

   - 用户名密码**正确**：返回用户权限（在上一步验证密码时，如果验证通过，会同时返回对应用户的权限）

在成功验证，读取权限之后，MySQL会为此创建一个**会话上下文**，每个连接都会有一个对应的会话上下文信息，其中包含该连接的所有状态信息，包括**权限信息**。

而在此次会话当中，需要的所有状态信息都将从这次缓存中读取。这也是为什么一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。

 

综上，成功通过连接器连接上了数据库。连接之后，可通过`show processlist`命令，查看MySQL当前所有的服务连接。`processlist`是位于`information_schema`的表，记录连接状态信息。

```sql
mysql> SHOW PROCESSLIST;
+----+-------+------------------+---------+---------+-------+-------------+-----------------------+
| Id | User  | Host             | db      | Command | Time  | State       | Info                  |
+----+-------+------------------+---------+---------+-------+-------------+-----------------------+
|  1 | root  | localhost        | testdb  | Sleep   | 10    |             | NULL                  |
|  2 | alice | 192.168.1.50:34567 | sales   | Query   | 0     | Sending data| SELECT * FROM orders  |
|  3 | bob   | 192.168.1.51:34568 | NULL    | Sleep   | 5     |             | NULL                  |
|  4 | carol | 192.168.1.52:34569 | hr      | Query   | 20    | Locked      | UPDATE employees SET salary = 5000 WHERE id = 1 |
+----+-------+------------------+---------+---------+-------+-------------+-----------------------+
```

`Command`和`State`记录当前连接的状态和信息。

MySQL服务器中有一个专门的后台线程管理连接和资源，他会定期运行，并检测所有连接是否健康。负责清理**空闲连接，释放资源，和其他定期维护任务**

如上方bob的连接状态是**Sleep**，如果此客户端太久没有操作，连接器就会将其断开，以释放服务器资源。具体时间由参数`wait_timeout`控制，默认为8小时。

此处所说的**断开**是**服务器端单向断开连接**，而客户端不会主动断开连接。假如在服务器端断开连接之后，客户端会遇到`“Lost connection to MySQL server during query”`错误，并需重新连接来继续操作。

MySQL中连接还区分有 **长连接 & 短连接**。此处的长连接指的是，使用同一个连接来处理客户端的持续请求。短连接则是每次执行完少量语句则断开，并再次新建连接。

在实际的使用过程当中，建立连接的过程事件开销比较大，所以相比之下，长连接更占优势。

但是MYSQL具有一个特点：**将执行过程中临时使用的内存管理、存储在会话上下文中**。这些资源的释放时机为**连接断开**。这就导致了一个问题：长时间使用同一长连接，从而导致MySQL占用内存急剧增大。

而卖你对这一问题，可以有以下两种解决方法：

1. 定期断开长连接，依据查询的次数 & 查询数据的多少，合理分配断开的时机。
2. 在执行大量操作后，通过执行`mysql_reset_connection`来初始化连接资源。相当于将该连接重置为服务器 & 客户端刚连接成功时状态。(mysql-version >= 5.7)



## 分析器