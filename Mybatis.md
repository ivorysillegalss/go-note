# Mybatis

### sqlSession的实现有什么？有什么区别？

有两个实现：`DefaultSqlSession` & `SqlSessionManager`

前者是mybatis的默认实现，默认直接与Mybatis的核心逻辑交互

后者是更加高级，封装化的实现。增强对`SqlSession`的管理，提供了更好的对线程安全性和事务功能



**线程管理**：

- **`DefaultSqlSession`**：不具备**线程安全**特性，直接使用时可能导致线程安全问题。开发者需要手动确保 `DefaultSqlSession` 在多线程环境中的安全使用。
- **`SqlSessionManager`**：内部使用 `ThreadLocal` 维护每个线程独立的 `SqlSession` 实例，天然支持多线程场景，保证每个线程使用自己的会话，不会互相干扰。

**事务管理**：

- **`DefaultSqlSession`**：需要手动管理事务的开启、提交和回滚。开发者必须在合适的地方调用 `commit()` 和 `rollback()`，并在使用完 `SqlSession` 后手动关闭。
- **`SqlSessionManager`**：提供了更加方便的事务管理功能，如 `startManagedSession()` 方法可以自动处理会话和事务的管理。事务的提交和回滚也更加直观，不需要手动传递 `SqlSession` 对象。





### mybatis中有什么使用了单例模式？

`ErrorContext` & `LogFactory`

- `ErrorContext`是用在线程范围内的单例，记录该线程的执行环境错误信息 **以线程为单位，使用ThreadLocal管理**

- `LogFactory`则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。 **以进程为单位**





### Nginx是如何处理一个HTTP请求的？

**多进程 & 事件驱动机制** 注意是进程不是线程

**通过多进程架构管理请求，在工程内部使用事件驱动机制处理请求**

多进程机制：Nginx中存在**主进程**和**工作进程**二概念，主进程负责对工作进程的管理，不直接参与数据交互。工作线程负责对客户端的连接和交互。当Nginx启动时，主进程根据配置中的(`worker_processes`)生成固定数量的工作进程，一般设置为**与CPU核数相同**。在此之中，主线程主要负责**维护 & 监控**等工作，当有工作进程寄了，会发送一个信号`SIGCHLD`。

事件驱动机制：epoll等。当有事件发生的时候，程序即触发对应的程序。同时并不会阻塞在某个事件中（非阻塞IO）。

Nginx中每个工作线程是单线程的，从而避免了并发时所会出现的问题。

**问：与CPU相同数量的工作进程是如何处理高并发的流量的**

答：事件驱动、非阻塞I/O、多进程协作、单线程模型等机制实现。



### Nginx的一些特性

反向代理 L7负载均衡器

嵌入式Perl解释器

动态二进制升级

重新编写url 具非常好的PCRE（Perl的正则式）支持



### ThreadLocal的原理

底层是一个特殊的HashMap，即ThreadLocalMap。key为ThreadLocal类型变量，value为Object类型键值对。当ThreadLocal没有强引用的时候，垃圾回收时，会将这个map中的key回收。也就变成了一个`key为null的键值对`，而ThreadLocal每一次执行`set() get()`等都会判断有无这种空key。如果有，将会全部清理掉。

why？因为如果不清理掉。所有的这些值都会一直遗留。而ThreadLocal还是以线程为单位的。所以会造成很大的空间消费。最终内存泄漏。这种做法**就是巧妙的利用了gc的机制 当gc回收键的时候 代表这个threadlocal变量不会再被使用 并且交由Threadlocal回收对应的值**





### MySQL中一行记录是怎么存储的？

![image-20240910170834719](C:\Users\chenz\AppData\Roaming\Typora\typora-user-images\image-20240910170834719.png)

MYSQL中行之间的存储通过链表进行连接

此部分记录多头信息，包括：

- delete_mask：标识数据的逻辑删除，若逻辑删除则设1，否则0
- next_record：类似链表的存储格式，存储的位置介于**记录头信息和真实数据**之间的位置。
- record_type：标识当前记录的类型。TODO 没明白

在头信息的右边是真实的字段值，左边则是`null值列表`与 **变长字段所占用的真实字节数**（当使用到变长字段时 需要先知道他真实的占用大小才能进行使用）

何为null值列表？数据库中的字段设置为NULL的话，就会创建对应的null值列表。用于记录这些值中，哪些字段的值是真的null，如果是null则设为1，非null设为0。并且在mysql中，是以字节为单位存储这些列的信息的。也就是说，若NULL字段少于8，会补齐前置0至8（单字节容量）。若超过了8个字段，则会使用两个字节进行存储。

那么这个NULL值列表是必须的吗？**否，如果所有字段都是NOT NULL，则没有这一值列表**

并且，需要注意到这个列是逆向存放的，理由稍候。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null%E5%80%BC%E5%88%97%E8%A1%A84.png)

同理，从上图可以看出需要同时存储变长字段字节数真实字节数。它使用1-2个字节表示对应变长字段的真实长度。（**0-255时1个字节 255-65535时两个字节**）同理他也不是必须存在的，如果不是变长字段，就不会有变长字段列表了。同时这个也是逆序存放。

所以到底为什么要逆序存放？

![image-20240910172905730](C:\Users\chenz\AppData\Roaming\Typora\typora-user-images\image-20240910172905730.png)

其实本质上就是读取的时候，由于是以一片数据为单位进行读取的。并且字段是顺序存放。这样子的操作就有更高的几率使他们在同一个窗口中被读取。

**Q：那是不是应该将变长字段放到数据库的前面方便读取？**

A：no，如果放在前面的话，如果变长字段数据更改的时候，修改了整个存储容量，可能会导致整个表此字段往后的字段都需要进行迁移。



### varchar(n) 中 n 最大取值为多少？

**MySQL规定除了TEXT、BLOBs这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息)占用的字节长度加起来不能超过65535个字节。**

很好记 2的16次方。但是这个65535指的是包含null值列表信息以及变长字段长度信息的。

```sql
CREATE TABLE test( 
`name` VARCHAR(65535) NULL
) ENGINE InnoDB DEFAULT CHARACTER SET ascii ROW FORMAT COMPACT;
```

如图，由于这个是变长字段，且大于255，并且是设置为NULL可空。所以上方的建表语句是不可行，需要2字节存储变量长度，1字节为NULL值列表。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/65532.png)

多行数时也是同理

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%9A%84%E6%83%85%E5%86%B5.png)

**MYSQL中的NULL值并不会存放在真实数据部分 那么如果是NULL值 真实数据部分存储的是什么？**

什么都不存，数据库跳过此字段



### MySQL中行溢出是怎么做的？

如果遇见blob等类型的时候，数据一下子存不完。此时InnoDB存储引擎会将数据存放到**溢出页**当中。

Ciompact会存一部分数据到当前页中，将剩余的数据放在溢出页。通过20字节的存储指向溢出页的地址，据此地址找到剩余数据所在的页。

Compressed和Dynamic这两个行格式和Compact非常类似，主要的区别在于处理行溢出数据时有些区别。这两种格式采用完全的行谥出方式，记录的真实数据不会存储该列的一部分数据，只存储20个字节的指针来指向溢出页。而实际的数据都存储在溢出页中

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA.png)

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png)

**如果溢出页也不够存怎么办？**

此时，在溢出页中，三种行格式除了存放数据，同时存放下一个存放页的指针。形式一个多存放页的链表。





### MySQL InnoDB 选择B+tree作为索引的数据结构

其实就是问B+的优点：

vs B树：

首先需要知道，在树的节点中，一般来说每个节点是由**空间上的大小限制**的。而B+树和B树最直观的区别就是，B+树的模式不在非叶子节点上存储数据，B树does。所以相同的情况下，同一个节点使用B+树可以促成农户更多的指针（分支），而相同情况下。更多分支意味着高度越小，高度越小则意味着磁盘IO的次数更小。从而提高了运行的效率。

同时，B+树的特点是有两个指针，一个指向根节点（root），一个指向最小的节点。分别赋给了B+树**范围查询和由小到大查询**的能力。B树明显无法做到这点。

vs 二叉树：

同理，对于二叉树。当数据的量级较大，二叉树的书稿会非常高。磁盘IO次数会更多。而B+树由于上述所说的特点，在数量级很大的前提下（千万级）。高度依然可以维持在3-4层左右。

vs Hash：

hash在获取等值，等值的时候效率非常高（O（1））。但是使用Hash没办法操作范围查询。



### 什么时候使用索引

- 经常使用where进行查询的字段
- 经常用于GROUP BY/ORDER BY的字段
- 有唯一性编码的字段



### 什么时候不需要创建索引？

- 使用不多（同上 WHERE / GROUPBY / ORDER BY中使用不到的字段）
- 存在的数据区分性不强， 重复较多（当重复性较强，mysql中的查询优化器甚至会选择不适用索引进行查询）

- 经常更新的字段
- 表数据太小（索引带来的收益 不如空间带来的开销）



### 索引什么时候会失效？

- 使用左模糊搜索，两边模糊搜索的情况下。（多种索引包括前缀索引等都会失效）

- 在where范围查询中，如果使用到了OR，而左方字段是索引列，右方字段不是。此时无法结合索引进行查询

- 在查询的时候，对索引列进行了计算，导致索引失效（个人理解：底层mysql将age + 1看成一个具体值 并且与索引中记录的值不同 所以无法使用）
- 使用索引的时候，不遵循最左匹配原则（简单来说就是，尽量使索引中字段与查询语句中约束字段顺序保持一致）
- 索引列非常建议使用NOT NULL进行约束



### 有什么优化索引的方法？

- 前缀索引优化（减少索引字段空间大小 orderby无法使用 无法作为覆盖索引）
- 覆盖索引优化（覆盖所有使用where等使用时会涉及到的字段）
- 主键索引自增（在最小程度改动树结构的前提下 增加新的数据 因为往树里新数据一般情况下只是加一个新字段的事）
- 防止索引失效 如上



## 事务

### 事务有什么特性？

ACID

A 4 Atomic **原子性**。

事务开始运行后数据只有两个状态，成功修改和失败修改（即修改前）的状态。

通过undo_log实现，why？undo_log记录用户进行的操作，一旦事务执行失败，则通过undo_log中记录的语句进行回滚。

C 4 Consistency **一致性**

原子性保证了数据只会有两种状态。而一致性保证事务中所涉及的修改数据会一起修改。**从一个一致状态修改至另一个状态**。通过其他三个特性一起保证。

I 4 Isolation **隔离性**

隔离性即，事务启动时，与本次事务无关的变量不会受到影响而改变。每个事务与数据库中正在执行的事务是隔离的。通过MVCC的多版本并发控制实现，MVCC通过它的事务控制来进行。除了MVCC还有锁机制实现，与**事务具体的隔离级别**控制。

D 4 Durability **持久性**

持久性即，事务对数据进行的修改是永远的。即使存储介质等出现故障也不会消失。通过redo_log实现，redo_log中保存了mysql曾经进行过的操作。通过这个重做文件重做，保证数据持久性。



并发的数据处理会导致并发的事务出现。意味着MySQL会出现同时处理多个事务的情况。



### 并行事务时会出现什么问题？

**脏读**

运行的事务有A B。若A事务修改了X字段，但是还没提交。此时B事务读到了已经被A事务修改的X字段。A事务又回滚了。就会造成B事务读到的是错误的值（尚未提交修改的值）

![](https://cdn.xiaolincoding.com//mysql/other/10b513008ea35ee880c592a88adcb12f.png)

**不可重复读**

运行的事务同理A B。若A事务需要多次读取同一个值X。但是在两次读取之间B事务对其进行了修改。就会造成两次读取中数据不一样的问题

![](https://cdn.xiaolincoding.com//mysql/other/f5b4f8f0c0adcf044b34c1f300a95abf.png)

**幻读**

运行的事务同理A B。若A事务需要多次进行统一约束下的查询。而在两次查询的过程中，B事务对其数据进行了修改，增加或减少了A事务查询的结果。就会导致A事务两次查询中得出的记录数量不一致。

![](https://cdn.xiaolincoding.com//mysql/other/d19a1019dc35dfe8cfe7fbff8cd97e31.png)

注意：

不可重复读指的是，多次读取同一个字段的**数据值**不一致。

而幻读指的是，同一个约束条件查询出的**记录条数**不一样

` select *`和`select count(*)`的区别



三种问题衍生出了SQL中的不同隔离级别

### 数据库中数据事务有什么隔离级别？

**读未提交**：事务未提交时，做的变更对其他事务可见（此时会导致脏读）

**读提交**：事务提交之后，所作的变更才能被其他事务可见（未提交时获取的还是之前的值）

**可重复读**：事务启动之后，就确定了这一次所操作的事务的版本。在之后的操作将只会操作这一个版本的数据。是**MySQL InnoDB 引擎的默认隔离级别**

**串行化**：会对记录加上读写锁。若A事务对字段进行了读写操作会堵塞住直至事务提交。B事务或其他都无法对其进行读写。

每个级别间都有一定的区别。读未提交就是最原始的。到了读提交，保证了一定的一致性。但是若A事务在两次读取同一个字段间，B事务对其进行了修改。就会导致A事务所操作的数据并非同一个版本。所有产生了可重复读的隔离级别。

可以看到越往下它的一致性就越好。当时相对应，它的执行效率会更低。（CAP一致性权衡）

![](https://cdn.xiaolincoding.com//mysql/other/4e98ea2e60923b969790898565b4d643.png)

### MySQL在可重复读下解决幻读的举措

快照读：普通的select语句，通过**MVCC**保证不幻读和一致性。本质上就是MVCC中存储了很多事务以及他们的id，当一个事务开启的时候，会记录这个事务所涉及到的字段的id。并且在后续的查询语句的时候，只根据这一id标识的值进行修改。

当前读：涉及数据修改或加锁的语句。通过 **next-key lock（记录锁+间隙锁）**方式解决了幻读。当执行的时候，若其他事务在锁的范围内插入了记录，这个插的行为会被**阻塞**而无法插入。从而避免幻读产生。

> 典型语句：`SELECT ... FOR UPDATE`、`SELECT ... LOCK IN SHARE MODE`、`UPDATE`、`DELETE`、`INSERT`等涉及数据修改或加锁的语句。



## 锁

### 全局锁

使用？ 

```sql
flush tables with read lock;
```

释放？

```sql
unlock tables;
```

当使用了全局锁，就只能读，所有的写操作都会被阻塞



### 全局锁的应用场景？

数据库的**全库逻辑备份**。锁住后，就不会因为数据或表结构的更新，而导致备份的数据的文件出错。用户只能进行**读操作**。

有什么坏处？因为是全程不可用的。所以会将所有的更新操作都阻塞住。影响业务。

有什么解决办法？如果数据库的存储引擎支持的事务支持**可重复读**的隔离级别，可以创建一个快照（Read View）。

如果结合使用的话，就可以备份某一个版本的数据的同时，其他业务同时进行更新操作。

![image-20240911195023867](C:\Users\chenz\AppData\Roaming\Typora\typora-user-images\image-20240911195023867.png)



### 表级锁

- 表锁

- 元数据锁（MDL）
- 意向锁
- AUTO-INC锁

**表锁**

```sql
//表级别的共享锁，也就是读锁：
lock tables t_student read;
//表级别的独占锁，也就是写锁：
lock tables t_student write;
```

即**读锁与写锁**，同样可以使用unlock tables释放所有锁

**当当前会话退出时，也会释放所有锁**



### 元数据锁

对MDL的使用一般是数据库自动加上的。

例如说在对表进行CRUD数据操作，加上MDL读锁。防止在读的时候修改了表的结构

在对表结构做变更操作时，加的是MDL写锁。防止在单次修改的时候，又同时进行了其他结构上的修改

### 那么MDL锁是在什么时候释放的？

事务提交后，意味着**事务执行期间，MDL是一直持有的**

![image-20240911200600930](C:\Users\chenz\AppData\Roaming\Typora\typora-user-images\image-20240911200600930.png)

产生这个的原因就是因为。首先读取的时候上了读锁。但是此事务不提交，读锁不被释放。此时就只能读，如果来了一个修改的请求，需要获取写锁，此时因为已有读锁。所以操作也会阻塞住。并且又因为获取锁的这一操作本身是队列形式的，所以当获取了写锁之后，之后所有读的请求都需要等待写锁成功获取并释放后才能进行。也就是一直阻塞住了。

![image-20240911200841685](C:\Users\chenz\AppData\Roaming\Typora\typora-user-images\image-20240911200841685.png)



### 意向锁

本质上的运行过程就是，想往一个颗粒度更大的层面上尝试加锁。做一个类似兼容性检查，如果这个兼容性检查通过了，就代表接下来加锁的整个过程是合法的。



### 行级锁 

下方所设计的所有的锁都有S锁和X锁之分

S锁-读锁 X锁-写锁

#### Record Lock

记录锁 锁住特定的一条记录

#### Gap Lock

间隙锁 锁住特定值间的一个范围

#### 插入意向锁

即如上 锁住前的一个意向锁