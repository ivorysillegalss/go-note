### ipconfig模块相关

#### ipconfig是什么？做了什么？

它是一个我自己设计的服务发现模块。他会读取配置文件中的服务配置，并且以etcd作为数据源。通过etcd的watch机制，实时监听业务前缀下服务状态信息的更改。返回当前的最优列表。并且暴露出对应的http接口可以让Nginx进行获取。



#### 数据是从exporter中获取的？这个模块有什么用？

这个模块所起到的作用主要是数据拉取和分析。他会从业务模块中通过gRPC+protobuf获取到对应的业务状态指标信息，例如说是当前的CPU内存，硬件资源，与请求数量和请求平均耗时等程序运行时指标。

当获取到这些指标之后，exporter会将这些信息put到etcd中。而ipconfig会通过etcd的watch监听机制立马得知。同时会将这些信息转换为http的格式，并且供以普罗米修斯进行拉取（监控模块）。



#### 介绍一下OpenResty

本质上是Nginx的增强。Nginx主要的作用是反向代理和Web服务器等。并没有其他更为复杂的功能，而OpenResty便是Nginx在这一维度上的一个拓展。



#### 如何实现ipconfig模块和Nginx之间的互动

主要是通过OpenResty中的定时机制和lua脚本实现热更新。

我的ipconfig模块中暴露了一个http接口。当请求这个接口的时候，可以获取到目前最优的服务列表。

在Nginx这一层面上。对于请求服务的路径，我们不会将他写死为对应某个服务的列表。而是将他写为读取Nginx中的共享内存。

所以实现的重点就在于如何更新这一个共享内存。我使用了OpenResty中的定时任务机制，这个定时任务会执行一个lua脚本。该lua脚本则会请求ipconfig服务器上的对应请求。从而更新缓存中的服务列表。

综合的来说就是。通过Nginx+的定时任务实现最优服务列表的更新，并将值更新到内存当中。请求到来的时候，就会直接读取该共享内存中的值。保证了服务列表的最优性和实时性吧。



#### 假如此时不巧由于网络波动的一瞬间，service_list[1]中的服务宕机了，这时候怎么办？

按照当前的设计的话，就只能等待下一次共享内存更新的时候，从其中获取更新后的服务列表。



#### 假如此时的Ipconfig模块宕机了，该怎么办

没宕机的情况下是访问服务列表中的最优服务。若宕机了，lua脚本请求的时候就会错误。此时我会根据上一次访问得到的最优列表，为每一个服务都定义一个兜底的权重。而当请求到来的时候，会在这个权重计算的基础上，再对各服务进行随机选择。这便是一种兜底策略。



#### 服务发现模块依赖的数据源是？为什么？

使用的是etcd，主要原因是当前的规模并不算大。属于用户量较小，压力较小的分布式场景。大部分情况下都是可以保证可用性。而根据CAP理论的话，我们可以偏向于使用一致性较强的中间件。而etcd由于是通过Raft协议实现的，保证了它的一个强CP。所以选择了etcd来兼顾一致性和可用性。



#### 有什么坏处吗这个方案？

因为etcd终究是属于CP模式的，所以高低会造成一点网络的延迟。兴盛一部分的可用性。但是这一部分的话，也可以通过缓存和配置调优的再度进行优化。



#### 如何得出当前的最优列表的？（具体的负载均衡算法是？）

当前的方案是以时间为颗粒度。我会针对每一个服务维护一个滑动窗口。这个滑动窗口则是最近的N个时间节点中的各个服务中的状态信息。然后当我需要获取这个最优列表的时候，我会给不同时间刻度的窗口以不同的权重。并且根据他们的这些权重和状态信息的指标所计算出一个加权平均。这个计算的颗粒度首先是以G为单位的，这是因为单位过小的话，对程序的运行没有太大的参考价值。



#### 这个算法求最终分数与遍历排序的过程会带来一定的时间延迟，怎么优化？

时间成本主要是来源于排序和计算。而计算的成本主要是遍历这个滑动窗口的时间复杂度。

具体的话，我们可以将当前时刻的所有窗口，先求出一个加权平均值。再根据这个值进行计算就可以了。减少了遍历次数。







### SSE & 流信息推送相关

#### SSE是什么？和WebSocket有什么区别？

SSE基于http协议，本质上是一种non-blocking的模式，只需要修改对应的请求头即可使用。WebSocket则需要升级协议才可以使用。

这也造成了WebSocket相比之下会比较中，SSE则比较轻量化。

SSE支持断线重连，WebSocket则需要自己实现这一模块。

SSE是单向通信，只能从服务端推送消息到客户端当中。WebSocket是全双工双向通信。

而对于这一场景来说。我作为服务端只需要将收到的消息推送给客户端即可，这一过程中不需要客户端做任何特殊响应，仅需要在消息传输后客户端返回ACK即可。



#### 如何使用SSE？

设置对应的服务器响应头就可以了

```
Content-Type: text/event-stream
Cache-Control: no-cache
Conection: keep-alive
```

本质上就是确保维持一个长连接，为了这个长连接不是收到缓存消息，设置为no-cache。同时信息是以流的形式发过来的，所以设置为text/event-stream