# 杂

### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

这一题最原本的思路可以使用暴力来解，使用**for循环  + 数组遍历**来找到每个窗口的最大值。此种方法思路较简单，每次窗口寻找最大值的时间耗费为`O(k)`，遍历整个数组时间耗费为`O(n)`。当**k**值变大或逼近**n**的值的时候，整个算法的时间复杂度就会退化为`O(n²)`。

观察题目可将所有值分为三种情况：

- 为数组的最大值
- 曾为数组的最大值 （被新的最大值所代替）
- 非最大值

而题目要求只需要我们获取前两种情况下的信息，也就是说，当我们推广出某个值**不为最大值**的事实后，可以直接将他舍弃掉，而只需要知道最大值之间的大小关系并且进行更新。更新的时候，**新加入的最大值与原本的最大值**并无直接的数量关系（无法写出简便的状态转移方程），所以dp行不通，我们可以试应用单调队列的方法。

若运用单调队列，队中元素依次递减，只需要在遍历的过程中，根据数据的大小关系不断更新队首元素并进行记录，就可以得到整个数组中各个浮动窗口的最大值。

首先需要构造一个双端队列，用于处理数组中元素的大小关系，并存储最大值的索引。为了维护队列的单调性，我们需要先将当前的元素(`nums[i]`)和队列中的末尾项比较，若`nums[i] > nums[q.getLast()]`（大于末尾元素），此时可以确定后者必为上述所说的第三种情况 **非最大值**。

> 因为单调队列的单调性，排在队内末尾的是相比之下值最小的项，若`nums[i]`比他还大，就说明了他不可能还会成为最大值。因为在它前面的值

当比较之后，我们将元素索引入队。此时得到了一个按递归存储元素索引的队列，只需要获取队首元素即可获取最大值。但是在获取之前，需要首先先确定是否在此盒子之中，即条件`i - q.getFirst() >= k`，根据索引判断，如果队首元素不在盒子内，剔除掉。

代码如下：

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 整个题目可以由左往右思考 我们只需要维护一个双端队列 进行入队和出队操作 并且记录每一次中的最大值
        
        int n = nums.length;
        int[] ret = new int[n - k + 1];
        Deque<Integer> q = new ArrayDeque<Integer>();
        
        // 双端队列中按照单调性 记录数组中的索引
        for(int i = 0;i < n;i ++){
            while(!q.isEmpty() && nums[q.getLast()] <= nums[i]){
                q.removeLast();  // 维护q的单调性
            }
        
        // 筛选掉不需要的元素索引 （不可能成为最大值的索引）
        q.addLast(i); 
        // 入队
        
        if (i - q.getFirst() >= k){
            q.removeFirst();
        }
        // 出队首元素

        if(i >= k - 1){
        // 保证此时有完整的盒子
        ret[i - k + 1] = nums[q.getFirst()];
                }
        }
		return ret;
    }
}
```







### [299. 猜数字游戏](https://leetcode.cn/problems/bulls-and-cows/)

你在和朋友一起玩 [猜数字（Bulls and Cows）](https://baike.baidu.com/item/猜数字/83200?fromtitle=Bulls+and+Cows&fromid=12003488&fr=aladdin)游戏，该游戏规则如下：

写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：

- 猜测数字中有多少位属于数字和确切位置都猜对了（称为 "Bulls"，公牛），
- 有多少位属于数字猜对了但是位置不对（称为 "Cows"，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。

给你一个秘密数字 `secret` 和朋友猜测的数字 `guess` ，请你返回对朋友这次猜测的提示。

提示的格式为 `"xAyB"` ，`x` 是公牛个数， `y` 是奶牛个数，`A` 表示公牛，`B` 表示奶牛。

请注意秘密数字和朋友猜测的数字都可能含有重复数字。

 

**示例 1：**

> 输入：secret = "1807", guess = "7810"
> 输出："1A3B"
> 解释：数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。
> "1807"
>   |
> "7810"

可以大体将所有的数字分成3类：

- bull 位置对数字对
- cows 位置错数字对
- nil 位置错数字错

设`s = secret.toCharArray() , g = guess.toCharArray()`

如何记录三种情况下的不同数字？不妨模拟一下，

- 若`s[i] == g[i]`，则bull++。不需要做额外的记录。

- 若两者不相等，说明此时的是`cows`或`nli`。即不知道`s`后方有无字符与此时的`g[i]`相对应（不能确定是否是`s[i]`），于是可以暂时寸放入两个数组当中，两个数组分别记录`s和g`当中，数字不一致的元素数量。

当遍历完数组之后，我们只需要取两个数组中的 **相同元素的 最小值** 便可确定**cows**的数量。

为什么呢？如果举个例子，就很容易明白。对于同一个元素，

代表对于`i`这个元素而言，`s`中只有`secretCount[i]`个，而对方则猜测了`guessCount[i]`个。

- 当`secretCount[i] < guessCount[i]`时，代表**对方猜测的元素**比**真实存在**的还要多，而cows的前提是真实存在的。所以此时B只能取`secretCount[i]`个，剩余的元素都是**位置错且数字错的**

- 反之，当`secretCount[i] > guessCount[i]`时，**真实存在的比猜测的要多**（例如说真实存在n个i元素，对方却只猜了n- 2个），但是题目是对猜测给予反馈的，这种情况下**猜错了n个位置，cows则为n**

换句话来说，其实就是cows的个数上限只能是真实存在的个数，只是将其推广开来能得到上面的结果。

```java
class Solution {
    public String getHint(String secret, String guess) {
        int bulls = 0, cows = 0;
        int[] secretCount = new int[10]; // 用于记录secret中未被匹配的数字及其出现的次数
        int[] guessCount = new int[10]; // 用于记录guess中未被匹配的数字及其出现的次数
        
        // 第一阶段：寻找所有的"bulls"
        for (int i = 0; i < secret.length(); i++) {
            char s = secret.charAt(i), g = guess.charAt(i);
            if (s == g) {
                bulls++; // 直接匹配增加bulls计数
            } else {
                // 记录未直接匹配的数字出现次数
                secretCount[s - '0']++;
                guessCount[g - '0']++;
            }
        }
        
        // 第二阶段：寻找所有的"cows"
        for (int i = 0; i < 10; i++) {
            // 对于每个数字，"cows"的数量由两者中较小的出现次数决定
            cows += Math.min(secretCount[i], guessCount[i]);
        }
        return bulls + "A" + cows + "B";
    }
}
```





### [331. 验证二叉树的前序序列化](https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/)

序列化二叉树的一种方法是使用 **前序遍历** 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 `#`。

![img](https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg)

例如，上面的二叉树可以被序列化为字符串 `"9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 `#` 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

**保证** 每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。

你可以认为输入格式总是有效的

- 例如它永远不会包含两个连续的逗号，比如 `"1,,3"` 。

**注意：**不允许重建树。

 

**示例 1:**

> 输入: preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
> 输出: true

**示例 2:**

> 输入: preorder = "1,#"
> 输出: false

**示例 3:**

> 输入: preorder = "9,#,#,1"
> 输出: false



题目给了我们一个前序遍历二叉树的字符串，我们需要在不重建树的基础上。确定其结构是否合法。

经过观察我们可以发现：从叶子节点出发，可通过将有效的叶子节点，使用`#`（空节点）来替换。此处借用力扣大佬的图

![image-20240331190228053](.\images\image-20240331190228053.png)

假如这棵树合法，我们可以将树**由大化小**，之后仅需基本的判断即可得出答案

但是，也会存在以下案例，2的左子树为空节点，右子树为非空节点。也就是在处理的时候，我们需要先将2的左节点相关数据**存储起来**，之后在进行处理。在这一应用场景下，由于先进后出，后进先出的特性，**栈**非常适合使用。代码如下

![image-20240331190642268](.\images\image-20240331190642268.png)

```java
public class Solution {
    private int index = 0; // 用于跟踪当前处理的节点在序列化字符串中的索引

    public boolean isValidSerialization(String preorder) {
        String[] nodes = preorder.split(",");
        // 尝试从根节点开始递归处理
        boolean valid = isValid(nodes);
        // 如果递归处理完所有节点后索引正好等于节点数组的长度，说明序列化有效
        return valid && index == nodes.length;
    }

    private boolean isValid(String[] nodes) {
        // 如果索引超出了节点数组的长度，说明序列化字符串不完整，返回false
        if (index >= nodes.length) {
            return false;
        }
        // 如果当前节点是空节点，递归的一个基本结束条件
        if (nodes[index].equals("#")) {
            index++; // 移动到下一个节点
            return true;
        }
        // 处理当前节点的左子树
        index++; // 移动到左子节点
        boolean leftValid = isValid(nodes);
        if (!leftValid) {
            return false; // 如果左子树无效，则整个序列化字符串无效
        }
        // 处理当前节点的右子树
        boolean rightValid = isValid(nodes);
        // 右子树是否有效由isValid的返回值决定
        return rightValid;
    }
}
```

AC之后，我在想既然它使用的是栈，并且题意也与dfs紧密相关，可不可以使用**递归**来解决。

一番摸索之后，就有了此版本

```java
class Solution {
    int i = 0;
    String[] nodes;
    public boolean isValidSerialization(String preorder) {
        String[] s = preorder.split(",");
        int n = s.length;
        this.nodes = s;
        boolean f = dfs();
        return i == n && f;
    }
    boolean dfs(){
        if(i >= nodes.length){
            return false;
        }
        if(nodes[i].charAt(0) == '#'){
            i ++;
            return true;
        }
        i ++;
        boolean a = dfs();
        if(!a) return false;
        boolean b = dfs();
        return b;
    }
}
```

这里dfs甚至不需要形参！

在遍历的时候，我们只需要维护一个索引，用于记录目前遍历到的位置即可。

乍一看代码也许非常不严谨，判断为错误的递归条件有且仅有**索引 > 节点数量**这一种情况

不妨先观察题意与代码逻辑：

- 非空节点    继续遍历其子节点

- 叶子节点    此分支遍历完毕

并且按照前序遍历的特点，当遍历完特定的左子树之后，其相同高度的右子树根节点即为左子树最右下节点索引 + 1。根据此特点可以推导出对应的dfs逻辑

下方为错误处理逻辑

1. **超出节点数组长度**：这种情况通常表示输入的前序序列化字符串在某个点不完整或者不匹配。例如，对于一个非空节点，序列化字符串中应该紧跟着两个子节点的序列化（无论是空节点`'#'`还是非空节点）。如果在处理过程中`index`超出了数组长度，这意味着序列在某个非空节点处没有足够的子节点信息来完成一个有效的序列化。这反映了序列化字符串中存在结构上的错误。
2. **结构违规**：在递归过程中，每遇到一个非空节点，算法都会尝试进一步递归验证其左右子节点。如果这个非空节点后面没有足够的节点信息（比如，缺少左子节点或右子节点的序列化），那么在递归过程中`index`会超出数组长度，导致返回`false`。这实际上检测到了序列化字符串中的结构违规，因为一个有效的二叉树序列化应该为每个非空节点提供完整的两个子节点信息（即使是空的）。
3. **提前终止**：如果序列化字符串在某个点之后仍有剩余节点，但这些节点由于结构上的问题（比如，缺乏合法的父节点关系）未能在正常的递归过程中被验证，算法也会因为`index`没有达到`nodes.length`而返回`false`。这种情况下，虽然不是直接通过超出长度来返回`false`，但最终的校验条件`valid && index == nodes.length`依然能够确保仅当序列化字符串完全匹配有效二叉树结构时，才认定为有效。







### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

**示例 1：**

> 输入：nums = [1,7,4,9,2,5]
> 输出：6
> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

**示例 2：**

> 输入：nums = [1,17,5,10,13,15,10,5,16,8]
> 输出：7
> 解释：这个序列包含几个长度为 7 摆动序列。
> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。

**示例 3：**

> 输入：nums = [1,2,3,4,5,6,7,8,9]
> 输出：2



1. **贪心**

**局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值**。

**整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列**。

对于题目的摆动序列，本质上可看成**山峰&山谷**

设abc对应的值为一个合法的山峰。则有`nums[c] > nums[b] > nums[a]`

同理若为一个合法的山谷。则有`nums[c] < nums[b] < nums[a]`

如何转化这里的条件呢？可以维护一个差值

- `int pre = nums[i + 1] - nums[i]`
- `int cur = nums[i] - nums[i - 1]`

而对于一个连续的摆动序列，我们需要保证山峰和山谷连续交替出现，换而言之，当出现合法的摆动序列时：

**第i轮的pre = i + 1轮的cur**，推广一下，也就是在第i + 1轮时，可以令`pre = cur`

知道了这一重要的结论之后，我们可以在原数组的基础上进行修改。当**符合对应的山峰or山谷要求**时，更新pre。实际上有点像维护状态。确定数组在**山峰和山谷**两种状态中进行切换。

我们如何知道上一次的状态？     维护pre，记录当前项与前一合法项的差值，若pre>0，则代表**此时为山峰**，应有cur>0。反之亦然

我们如何处理平坡(`nums[i] == nums[i + 1]`)的状态？      平坡的状态可分为两种，我们可以根据上方`pre = cur`的方式进行处理

- 先平后变`[1,1,1,2]`    若`i = 3`，此时`cur = 1`，`pre = 0`，（**pre在`i = 2`的时候进行处理并需要进行更新**）

- 先变后平`[5,3,3,3]`    若`i = 2`，此时`cur = 0`，`pre = -2`，(**pre在`i = 1`的时候更新为cur的值，即3 - 5**)

根据上方的分析，我们可以知道当pre = 0的时候需要更新为cur，不然在平 - 变的过程中，无法处理比较的逻辑。代码如下：

时间复杂度为`O(n²)`

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int pre = 0;
        int cur = 0;
        int n = nums.length;
        int cnt = 1;
        for(int i = 0;i < n - 1;i ++){
            cur = nums[i + 1] - nums[i];
            if((pre <= 0 && cur > 0) || (pre >= 0 && cur < 0)){
                cnt ++;
                pre = cur;
            }
        }
        return cnt;
    }
}
```



2. **dp**

在上方贪心的做法中，我们直接通过删除不必要的节点，通过一次遍历，获取**一个且仅一个**最优的序列。并且在上方的做法当中，我们也根据平与变两种情况分析了不同的状态：

- i为山峰，则i+1为山谷
- i为山谷，则i+1为山峰

整个i变化的过程也是一个由山谷转为山峰的过程。

由此我们可以尝试将题目使用dp来解决，定义dp数组`dp[n][2]`，其中`dp[i][0]`表示山谷时子序列最长长度，`dp[i][1]`表示为山峰时子序列最长长度。使用这种做法，与贪心不同，我们是求出每一个点，作为**山峰和山谷的最长序列**，时间复杂度上是`O(n²)`，代码如下：

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;
        int[][] dp = new int[n + 1][2];
        for(int i = 0;i < n;i ++){
            // 0表示山峰 1表示山谷
            dp[i][0] = 1;
            dp[i][1] = 1;
            for(int j = 0;j < i;j ++){
                // j为i前面的元素 j大于i时 此时为山谷
                if(nums[j] > nums[i]){
                    dp[i][0] = Math.max(dp[i][0],dp[j][1] + 1);
                }else if(nums[j] < nums[i]){
                    dp[i][1] = Math.max(dp[i][1],dp[j][0] + 1);
                }
            }
        }
        return Math.max(dp[n - 1][0],dp[n - 1][1]);
    }
}
```







### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**子数组**是数组中的一个连续部分。



分析题目要求：

- 连续
- 最大



1. **贪心**

我们依旧使用局部贪心和全局贪心的思路讨论

设遍历到任意个位置时的连续和为sum

局部贪心：寻找连续和，如果 sum > 0，则继续寻找；如果 sum < 0，则立马重置为当前位，重新计算子序列的长度。因为在sum < 0的情况下仍继续叠加，则不满足题目中**最大**一要求了。

于是就可以得出类似这一条件：`if (sum < 0)    sum = 0`

全局贪心：寻找最大的局部贪心，即最大的连续和，可以使用一个变量max来进行维护

代码如下：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int value = 0;
        int max = -1 * Integer.MAX_VALUE;
        for(int i = 0;i < n;i ++){
            value += nums[i];
            max = Math.max(value,max);            
            if(value < 0) value = 0;
        }
        return max;
    }
}
```





2. **动态规划**

上方讨论贪心时，相信有读者已经有想到了dp，这一题dp和贪心的思想非常像，我们通过维护一个dp数组，记录前i项的最大数组和`dp[i]`。

知道了dp数组的含义，接下来我们应该寻找状态转移的条件，即讨论从第i个状态切换到i+1个状态时有什么需要改变。我们之前在贪心的做法中有说到。

> 局部贪心：寻找连续和，如果 sum > 0，则继续寻找；如果 sum < 0，则立马重置为当前位，重新计算子序列的长度。因为在sum < 0的情况下仍继续叠加，则不满足题目中**最大**一要求了。

这一部分跟动态规划是大致相同的，在这里其实`dp[i] == sum`，甚至sum作为一个变量还做了空间上的优化。依照这一特性，我们可以写出状态转移方程为`dp[i] = Math.max(dp[i - 1] + nums[i],nums[i])`     代码如下：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n + 1];
        int max = nums[0];
        dp[0] = nums[0];
        for(int i = 1;i < n;i ++){
            dp[i] = Math.max(nums[i],nums[i] + dp[i - 1]);
            // 上下方的写法效果是一样的
            // dp[i] = dp[i - 1] > 0? nums[i] + dp[i - 1] : nums[i];
            max = Math.max(dp[i],max);
        }
        return max;
    }
}
```

