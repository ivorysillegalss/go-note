### [78. 子集](https://leetcode.cn/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

**示例 2：**

> 输入：nums = [0]
> 输出：[[],[0]]



此题是**子集型回溯**的经典模板题，通过观察可以发现。枚举一个数组的子集，本质上就是在**枚举每一个元素加入此子集与否**的情况。因此只需要分别对**加入**、**非加入**的情况进行深度优先遍历即可得到答案。我们dfs时维护一个**索引i**，记录此时遍历到的位置。

此处借用灵神的图以[1,2]为例。当索引为0(`dfs(0)`)时，可选择是否将`nums[0]`计入子集中，并将两种情况分开进行讨论。

- 若无需加入，可直接遍历下一元素`dfs(1)`
- 若需要加入，加入当前元素`nums[0]`，然后进行下一次遍历`dfs(1)`

当每一次遍历之后，需要恢复现场，即`path.remove(path.size() - 1);`

下为代码：

![image-20240323233330277](.\images\image-20240323233330277.png)

```java
class Solution {
    List<List<Integer>> ret;
    int n;
    List<Integer> path;
    int[] nums;
    public List<List<Integer>> subsets(int[] nums) {
        this.nums = nums;
        ret = new ArrayList<>();
        n = nums.length;
        path = new ArrayList<>();
        dfs(0);
        return ret;
    }
    public void dfs(int i){
        if(i == n){
            ret.add(new ArrayList<>(path));
            return;
        }
        dfs(i + 1);

        path.add(nums[i]);
        dfs(i + 1);

        path.remove(path.size() - 1);
    }
}
```

