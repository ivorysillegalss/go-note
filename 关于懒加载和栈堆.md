### 关于懒加载和栈堆

懒加载在操作系统中的体现可以动态链接和虚拟内存

对于动态链接 我们会在程序的对应部分记录一个空

假如运行到这里了 就会根据PLT和GOT寻找遍历方法 

找到对应的方法栈堆区并加载过来

对于虚拟内存 我们则会以进程为单位 分配缓存页

在不同的线程中 他们可能会出现同样的一个地址空间

这个地址空间是虚拟的 在调用到的时候 操作系统会通过CR3（一个存放的寄存器）

查找到其对应的物理地址 并且将这一页加载进来

这本质上就是懒加载的一个鲜活体现



在JVM中 也存在对应的体现 有java虚拟机栈 本地方法栈

两者本质上是存储不同方法的运行时实际数据

而这个栈帧的加载就是懒加载 当运行到这个方法的时候 才会将对应对容加载进来



### 执行方法时静态变量与线程安全相关

对于多线程环境下，我们首先看到的是，假如多个线程同一时间执行某一个方法，改变了某一个静态变量，则会出现竞态问题。所以我们发明出volatile关键字，保证程序的有序性，原子性，可见性。

这个底层可以理解为。在执行方法的时候，我们会从原空间获取到类的信息，并根据这个信息为不同的线程创建不同的栈帧。

而不同的线程操作静态变量的时候，他们不会去为静态变量创建副本（这里的他们指方法中的栈帧）。他们是直接操作堆中的共享对象。

**但是**

JVM中做了优化，会在**CPU的高速缓存**中放置静态变量的缓存。

而根据存储的不同层级推理一下，我们就可以知道，在方法获取变量执行的时候首先肯定是先查询CPU高速缓存，如果有的话就返回。没有的话再去主存中进行寻找。

而这个CPU的高速缓存就导致了老生常谈的竞态问题

volatile变量的本质，就是**禁止CPU缓存优化**。将每一次的更新操作都立同步到主内存，而读取的时候，也直接从主内存（堆）中读取。保证了读写操作与主内存同步。



### 堆和栈

栈和堆中存什么？

从生命周期来看，一个栈本质上就是一个方法的逻辑体现，在方法结束之后，栈就会消失，里面的数据也会被销毁；

堆本质上是共享内存（临界资源），它存储了所有栈没存上的运行时数据。而堆中的数据只会通过GC线程将其回收。

方法中涉及的所有基本数据类型变量都会存储到栈中，为什么？其所占空间小。

相反的，引用类型（包括数组）所占用的空间大。所以会存在堆中，存储空间大，然后等待GC回收。



### 方法区中执行方法的执行过程

方法区本质上是对外内存也就是直接内存。这个内存是不归JVM管的，是操作系统的部分内存。

首先通过方法区找到对应的方法地址信息。根据这个信息，创建对应的栈帧，并且根据信息内的指令不断的执行，最后返回执行完毕的状态。



### 创建对象的过程

1. **类加载检查**，检查这个类此前是否被加载过。通过符号引用实现，**符号引用**本质上与类信息形成一个**映射关系**。通过判断有没有符号引用就知道有没有相关的类信息。
2. 根据获得的类信息，为新对象在堆中分配对应的空间。
3. 为新对象中的各个属性赋零值

4. 在方法区中记录对象的元信息，（对象头等）
5. 执行构造函数，init 方法
6. **初始化完成**



### 双亲委派模型

#### 有哪些类加载器？

启动类加载器 负责加载类的核心库 核心代码

扩展类加载器 负责夹杂扩展目录，包括依赖等

应用程序类加载器&系统类加载器 两者的本质上是一样的，负责加载用户设置的类

自定义类加载器 开发者自己定义的类加载器



#### 类加载器加载类的过程

当类的加载请求到来时，会先给到子类类加载器，但是子类加载器本身先不直接加载它。而是把加载的请求给到父类加载器，依次传到最顶层的加载器。所以无论是什么类需要加载

他都需要到达最顶层的加载器当中

即Bootstrap Class Loader

然后父类加载器判断自己怎么能不能加载这个类，如果不能记载，就还给子类加载器开搞。

所有类都是这么干的



#### 加载器怎么判断自身能不能加载他？

通过加载器的缓存和类路径（Classpath）。

并且可以加载器可以通过类名推断处其全路径，从而进行加载。



#### 为什么需要它？

保证了加载时类的安全性以及记载的类的唯一性。

按照这一设计，所有的类都是先通过父类加载器先判断扫描的。就保证了它的安全性。因为加载器仅加载它信任的目录内的包。

假如有人恶意定义一个System包，那他也不在新人的目录内，所以无法加载的到java库中。

并且按照这个设计，就解耦了不同层次的包的加载。启动类只加载核心的类，扩展仅加载依赖相关的类。自己定义的Classpath会在应用程序加载器或自定义加载器中加载出来。



#### 为什么说SPI机制会打破双亲委派机制

SPI机制在JAVA中的体现是，实现标准库所提供的一个接口，并且通过在配置文件中配置。让JAVA加载这个类。

Java中SPI机制的体现最鲜明的有JDBC。但是问题来了，如果使用SPI机制的话。三方实现按理来说应该是通过扩展类加载器或者是应用程序加载器。但是SPI不会走这条路，对应的加载器就直接对他进行加载。而不会执行双亲委派机制原有的环节。



#### 加载类的真实过程

加载：首先从字节码文件中加载类，在方法区中分配空间。

验证：分配空间后会对类的相关信息（元信息）进行验证，验证其是否准确。

准备：假如准确的话，就会给其中的静态变量在堆中开辟空间，赋零值。

解析：将常量池中的符号引用（即虚拟地址）转换映射为真实的直接引用（真实地址）

初始化：执行编译器自动生成的构造器方法。这个构造器方法中的逻辑本质上就是给静态变量赋值，并且执行静态代码块。

使用：正确使用创建对象

卸载：其对应的ClassLoader已经被回收；不存在她所对应的对象实例；代码中没有指向它的反射引用
