# mysql事务隔离

如前文所说，MySQL可"热插拔"引擎，其原生引擎MylSAM不支持事务，InnoDB可支持。

提到事务，其最出名特点即为ACID，原子性，隔离性，持久性，一致性。此处重点介绍它的“**隔离性**”

隔离级别可详细分为以下：

- **读提交**：事务**提交**之后，所作的变更会被其他事务看到
- **读未提交**：事务**还没提交**时，所作的变更就能被别的事务看到
- **可重复读**：事务在执行过程中看到的数据，跟事务在启动时所看到的数据是一致的（快照）。未提交变更对其他事务也是不可以见的
- **串行化**：对于同一行记录，“写”加“写锁”，“读”加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。



下方直接搬原文好例

> 假设数据表T中
> 只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。
>
> ```sql
> mysql> create table T(c int) engine=InnoDB;
> insert into T(c) values(1);
> ```
>
> ![image-20240716191758157](C:\Users\chenz\AppData\Roaming\Typora\typora-user-images\image-20240716191758157.png)
>
> - 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
> - 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以，V3的值也是2。
> - 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：**事务在执行期间看到的数据前后必须是一致的。（不随数据外部改变而改变）**
> - 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。

可以看出除了**串行化**，其他三隔离级别差别仅在于返回不同时机的数据，如何实现？

“可重复读” & “读提交” 由创建视图实现

在访问数据的时候，事务访问结果以此时图逻辑结果为准

- 可重复读 在 **事务启动时** 创建
- 读提交 在 **每个SQL语句开始执行时** 创建



可通过设置启动参数`translation-isolation`进行配置，也可用`show variables`查看当前的值。



### 具体的实现过程：

MySQL中，在记录更新操作的同时，也会记录一条回滚操作。通过回滚操作，可将最新之回滚至前一状态的值

![image-20240716200000533](C:\Users\chenz\AppData\Roaming\Typora\typora-user-images\image-20240716200000533.png)

当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的`read-view`。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4。同一个系统可以存在多个版本，即 **多版本并发控制系统(MVCC)**。

同理，如果想要得到1，就必须要将当前值依次回滚得到。