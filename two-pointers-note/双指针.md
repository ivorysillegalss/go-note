# 双指针

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/) (or 前缀和)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```



这一题可以使用前缀和思考，能接雨水的量首先**取决于(两边柱子的高度 - 当前柱子的高度)**，即可以推广成后缀和的高度最大值与前缀和高度最大值取最小值。与当前高度相减。

设前缀和高度为**preMax** 后缀和高度为**sufMax** 当前柱子高度为**height[i]** 高度为**sum**

分析能接雨水的情况：

- preMax <= sufMax , sum += preMax - height[i] （两者相等时 所相减的值都是一样的）
- preMax > sufMax , sum += sufMax - height[i]

依照上方的思路，我们可以首先想到利用两个辅助数组，记录每一个点的`preMax`和`sufMax`的值。记录下来之后进行再次遍历，依照前后缀和关系（前后柱子的高度）来对雨水数量进行计算。这一种方法要进行3次遍历（或可以同时记录preMax和sufMax，优化为两次），空间上使用到了两个辅助数组。所以其时间复杂度为`O(n)`，空间复杂度也为`O(n)`。

代码如下：

```java
class Solution {
    public int trap(int[] height) {
        if (height == null || height.length < 3) {
            // 如果数组为空或者长度小于3，不能积水，直接返回0
            return 0;
        }
        
        int n = height.length;
        int sum = 0;
        
        // 创建两个数组，分别存储每个位置左侧和右侧的最大高度
        int[] leftMax = new int[n];
        int[] rightMax = new int[n];
        
        // 初始化左侧最大高度数组
        leftMax[0] = height[0];
        for (int i = 1; i < n; i++) {
            leftMax[i] = Math.max(height[i], leftMax[i - 1]);
        }
        
        // 初始化右侧最大高度数组
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            rightMax[i] = Math.max(height[i], rightMax[i + 1]);
        }
        
        // 计算每个位置上可以积累的雨水量，并累加到总和中
        for (int i = 0; i < n; i++) {
            sum += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        
        return sum;
    }
}
```

成功AC，我们可以再次观察得知，计算接雨水的数量在于三个条件：

- 当前位置是**左右柱子的大小关系**
- 短的柱子的高度是多少
- 当前木板的高度是多少

在题目中我们可以发现，若遍历到的点的木板高度小于左右木板时，不需要进行任何除记录值外的任何操作，换句话来说。再不更新前后缀和的情况下，木板的最大高度适用于**多个连续的木板**，从此可以推断出也许我们可以在空间上在做些许优化。并不需要维护所有柱子的前缀和、后缀和的值，以一个变量来记录最新的前后缀和高度即可。结合木板相向的使用场景。我们也许已经可以联想到双指针了。

这一做法与上述前缀和遍历点顺序有所不同，前者是把所有点的前后缀和获取后，通过for循环从头遍历到尾。而此做法则是根据前后缀柱子高度浮动，（本质上还是前缀和的思想，只是节约了记录的空间）若前缀和(左边柱子的最高高度)小于后缀和(右边柱子的最高高度)，则移动左指针，记录移动的方位的雨水数量，反之同理。

也许读者可能会对具体的代码运行过程有困扰，我们这里以示例一为例：

（以while循环次数为基准）

- 第一轮：更新sufMax为1(`height[height.length - 1]`)，preMax与`height[0]`值相等均为0，`sufMax > preMax`移动左指针`l = 1`，sum加0仍为0
- 第二轮：同理更新preMax，左右柱子高度相等，sum = sufMax(也可以是preMax) - height[l] (也可以是height[r])，即sum加0仍为0，更新右指针（根据写法不同也可以是左指针，这里以下方代码为准）
- 第三轮：sum值仍为`preMax-height[1]`，sum仍为0，更新左指针`l = 2`
- 第四轮：`height[2] < preMax`，此轮不需要对值进行更新。`preMax < sufMax`，所以sum += sufMax - preMax，即+1，移动左指针。 

代码如下：

```java
class Solution {
    public int trap(int[] height) {
        int l = 0;
        int r = height.length - 1;
        
        int preMax = 0;
        int sufMax = 0;
        // 此处使用两个变量来代替两个数组
        
        int sum = 0;
        // 双指针做法：当木板长度不一样的时候 站在短板的角度思考
        // 当计算某一个点能装的雨水的时候 不需要具体知道两边柱子的高度
        // 只需要知道 谁短 值是多少 当前的木板高度是多少
        // 若不知道某一个点的上述三条件 则关注另外的指针
        while (l <= r){
            preMax = Math.max(height[l],preMax);
            sufMax = Math.max(height[r],sufMax);
            
            if(preMax < sufMax){
                sum += preMax - height[l];
                l ++;
            }else{
                sum += sufMax - height[r];
                r --;
            }
            
        }
        return sum;
    }
}
```

复盘再次分析，可以发现可以将所有情况分为两类。

- 更新高度：此时的preMax或sufMax与对应的柱子高度height[i]相等，sum不变

- 计算雨水，不更新高度：此时不需要更新两者的值，也就意味着height[i]和preMax或sufMax存在差值，sum增加
