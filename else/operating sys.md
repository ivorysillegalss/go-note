operating sys

瞎记乱学

## 应用层面

所有的程序本身只有数据，而在程序运行中只有数据的处理。程序本身是没有能力打开或关闭的 需要依赖于系统调用(system call)

> 在操作系统的上下文中，程序本身是由数据和代码组成的静态实体，它只有在被加载和执行时才会成为一个动态的进程。程序本身没有能力自行打开或关闭，而是依赖于操作系统提供的系统调用（system call）来执行这些操作。

所有的程序都可以理解为一个黑盒子 sandbox

所有的软件都只是设计了对应数据的IO 

窗口 浏览器等页面也是同理 软件本身并不具备打开窗口的能力

而是各操作系统上提供了一个**任务管理器** 此任务管理器提供对应的api给各软件

当某个软件需要创建新窗口的时候 他就会将创建对应窗口的参数传给任务管理器

任务管理器将此创建新的窗口并同统一对其进行管理



> **任务管理器到底算是操作系统的一部分还是软件的一部分？**
>
> 如果站在软件上看 它也是IO对应的数据 并将其进行处理 只是它所output的方式是图形化界面而已
>
> 如果是操作系统 它通过syscall获取对某些系统资源（CPU占用率）的访问权限。也实现了属于自身的系统调用 （它可以新建 & 结束某些其他进程）
>
> 综上，虽然应用管理器本身只是一个用户空间的应用程序，但他通过与操作系统内核的紧密交互实现了类似“系统调用的功能”
>
> 
>
> **上述只是本人一些思考**



> 万物皆是状态机

如上所说 所有的程序都是无非都是数据的处理 同时也是状态的切换。

任何一个程序 包括从高级语言到c语言到汇编

基本上都是围绕着状态的切换

从这一角度上看 c语言中的编译 无非就是讲状态切换的逻辑转换描述方式 罢了



M1 打印进程树 pstreehttps://jyywiki.cn/OS/2024/labs/M1.md

> Everything is file

首先展示pstree运行效果

![image-20240727154511627](.\images\image-20240727154511627.png)

此命令将正在运行的进程与其父进程方式 以树的方式输出



根据上方的思路，我们可以设想所有的进程及其信息，包括其窗口化的信息等。也许会统一存储在某个文件当中

在linux当中，存储在`/proc`目录下，进入目录可以看到许多以数字为编号的文件夹。可以料想到每一个编号其实就是每一个进程的编号（PID）。

下方使用linux中ps命令查看 正在运行的进程



![image-20240727154202464](.\images\image-20240108152543702.png)

然后在proc目录下进入对应2237目录 vim打开status文件 （此文件存储进程的名字）

此处的PPID即是对应进程的父进程

![image-20240727154332631](.\images\image-20240727154332631.png)

根据上方目录可知道所有进程的父进程都是systemd 且其进程PID为1

进入对应目录可发现它的父ID是0



综合以上的信息，我们可以用proc来记录，获取每一个进程的运行状态和他的父进程。之后只需要以递归，遍历树的方式将其组织输出出来就好了。 





## 硬件层面

依然以状态机模型思考 计算机系统运行的过程及其中的任何步骤其实都可以以状态机模型进行思考

由数字电路中的与非等逻辑 直至 汇编代码 高级语言 

每一行语句的逻辑处理 本质上都是一种状态的切换



现在已整个计算机启动的角度 以状态机模型进行思考 可以分析为

- 初始状态：由**硬件 & 操作系统**设计者自定义 （CPU Reset）

- 状态： 每个**内存 & 寄存器**中存储的数值
- 状态转移：执行指令 （由PC寄存器中取出）

> 一个现代的计算机中 会同时存在**多核多线程**
>
> 但是他们是共享同一块内存的 在这样的情况下
>
> 可以往状态机模型上加多一步 : **在执行指令的时候 每次选一个处理器执行一条指令**
>
> 之后会详细研究

接下来 将解析一部分操作系统运行时的启动流程 （很多概念）

忽略硬件的实际运行细节 以QEMU模拟计算机启动时的硬件条件 (不严谨的可以将其理解为VMware)

> QEMU（Quick Emulator）是一种通用且开源的机器仿真和虚拟化工具。它可以模拟多种硬件平台，使得用户能够在一种架构上运行另一种架构的软件，例如在x86系统上运行ARM软件。QEMU主要有两种模式：用户模式仿真和系统模式仿真。以下是对QEMU的详细介绍：
>
> ### QEMU的主要功能
>
> 1. **用户模式仿真**：允许在一种架构上运行另一种架构的用户空间程序。例如，可以在x86架构的计算机上运行ARM架构的程序。通常用于跨平台开发和调试。
> 2. **系统模式仿真**：可以模拟整个计算机系统，包括CPU、内存、硬盘、网络接口等。这种模式下，QEMU可以运行完整的操作系统，如Linux、Windows等。常用于虚拟化环境和操作系统开发.

于是可以有:

1. QEMU启动,指定虚拟机的配置信息,模拟出一个计算机系统所需的组件.
2. 根据QEMU中的配置,加载BIOS或UEFI固件.

> **固件是什么?**
>
> 固件是当**计算机系统硬件运行时 或 虚拟环境启动时**,所自动执行的代码
>
> 它启动初始化各计算机设备 并加载计算机系统本身的引导程序(GRUB)
>
> 
>
> **BIOS 和 UEFI 是什么?**
>
> BasicInputOutputSystem  & Unified Extensible Firmware Interface
>
> 见名知义 两者是不同规范的固件接口
>
> 不同配置的计算机硬件接口不一样 从而产生不同标准的固件规范
>
> BIOS主要支持16位 UEFI可支持32位或64位 但一般现代计算机也兼容BIOS
>
> 
>
> 在计算机实际启动的过程中,两者的工作流程也并不完全一样.
>
> (此处先忽略两者工作流程的异同,仅大致描述运行机制)

3. BIOS或UEFI进行内存,CPU的初始化工作. 扫描可引导的设备和分区(跟操作系统没有直接关系)
4. BIOS或UEFI加载GRUB引导程序

> **什么是GRUB?**
>
> GRUB是在计算机启动的时候 给用户的一个引导加载程序
>
> 在启动时 若有多个操作系统 用户可以选择登录进任意一个
>
> 这便是GRUB的功劳
>

回顾一下以上的多个步骤 目前已经初始化了硬盘等设备的相关信息.并且成功加载了引导程序.于是有:

4. GRUB读取配置文件,得到可执行的操作系统的列表,给予用户进行选择.(注意,这一过程本质上和上方BIOS或UEFI初始化 **没有任何关系**)
5. GRUB加载所选操作系统内核,启动



在这过程中,还有很多细节可以进行细究.

- 譬如说GRUB并不是一个单独实体,而是一个分阶段运行的引导加载程序,只是他们在启动的不同部分都起到了引导的作用



### GRUB的启动过程

1. **BIOS初始化和MBR加载**
   - BIOS执行POST，初始化硬件。
   - BIOS从启动设备的MBR加载并执行GRUB的Stage 1代码。
2. **Stage 1加载Stage 1.5或Stage 2**
   - Stage 1代码执行，从磁盘空闲区域加载Stage 1.5代码（如果存在）。
   - Stage 1.5提供文件系统支持，从文件系统中加载Stage 2。
   - 如果没有Stage 1.5，Stage 1直接加载Stage 2。
3. **Stage 2执行**
   - Stage 2代码被加载到内存中并执行。
   - Stage 2读取配置文件，显示引导菜单。
   - 用户选择操作系统或进入命令行模式。
   - GRUB加载操作系统内核和初始内存盘，设置内核参数。
4. **转移控制权**
   - GRUB将控制权转移给操作系统内核，内核开始执行，完成系统启动。





- 譬如说UEFI和BIOS的具体工作流程其实是有差别的

- 譬如说在GRUB加载时,会将CPU的控制权由GRUB本身转移到操作系统内核(Linux)等------CPU控制权限在启动系统时的转移流程

以上两个问题其实可以综合进行讨论

### 控制权的定义和转移过程

**控制权（Control）**指的是计算机系统中由哪个程序或代码块在某一时刻掌握CPU的执行权，控制系统的运行流程。当我们讨论启动过程中的控制权转移时，指的是从一个阶段的代码执行完毕后，将CPU的执行权交给下一个阶段的代码。

### 控制权转移的具体过程

#### 1. 固件初始化（BIOS或UEFI）

- **BIOS模式**：
  - **BIOS初始化**：BIOS执行POST（Power-On Self-Test），初始化硬件并检测启动设备。
  - **加载MBR**：BIOS从启动设备的MBR（主引导记录）加载并执行引导代码。此时，控制权从BIOS转移到MBR中的引导代码。
- **UEFI模式**：
  - **UEFI初始化**：UEFI固件初始化硬件，执行POST。
  - **加载EFI应用程序**：UEFI从EFI系统分区（ESP）加载GRUB的EFI应用程序。控制权从UEFI固件转移到GRUB的EFI应用程序。

#### 2. GRUB引导加载程序

- **加载和执行GRUB**：
  - **BIOS模式下的GRUB**：
    - **Stage 1**：MBR中的引导代码加载GRUB的Stage 1代码。
    - **Stage 1.5（如果存在）**：Stage 1代码加载Stage 1.5代码，提供文件系统支持。
    - **Stage 2**：Stage 1或Stage 1.5加载GRUB的Stage 2代码。此时，控制权转移到GRUB的Stage 2。
  - **UEFI模式下的GRUB**：
    - **GRUB EFI应用程序**：UEFI固件加载并执行GRUB的EFI应用程序。此时，控制权转移到GRUB的EFI应用程序。
- **GRUB执行**：
  - GRUB选择操作系统内核和初始内存盘并进行加载

#### 3. 操作系统内核启动

- **加载操作系统内核**：
  - GRUB将操作系统内核和初始内存盘加载到内存中，设置内核参数。
  - **转移控制权到内核**：GRUB完成内核加载后，将CPU的执行权交给操作系统内核的入口点。此时，控制权从GRUB转移到操作系统内核。
- **操作系统内核初始化**：
  - 操作系统内核开始执行，初始化硬件和系统资源，启动内核服务。
  - 内核完成初始化后，启动用户空间的进程和服务。

### 具体的控制权转移点

1. **BIOS或UEFI初始化完成后**：
   - **BIOS模式**：BIOS加载并执行MBR中的引导代码，控制权转移到MBR中的GRUB Stage 1代码。
   - **UEFI模式**：UEFI加载并执行GRUB的EFI应用程序，控制权转移到GRUB的EFI应用程序。
2. **GRUB加载并执行**：
   - GRUB读取配置文件，显示引导菜单，加载操作系统内核。
   - GRUB将操作系统内核加载到内存中，控制权转移到操作系统内核。
3. **操作系统内核启动**：
   - 内核接管控制权，初始化硬件和系统资源，启动用户空间的进程。



其实就是 `BIOS/UEFI -> GRUB -> 操作系统内核 `

> **什么是MBR?**😂
>
> ### 主引导记录(扇区)
>
> 1. **MBR的定义**：
>    - 主引导记录（Master Boot Record, MBR）是硬盘上的第一个扇区（通常是512字节），它包含引导加载程序和分区表。MBR的主要作用是在系统启动时引导操作系统。
> 2. **MBR的组成**：
>    - **引导代码**（Boot Code）：前446字节，包含用于启动引导加载程序的代码。
>    - **分区表**（Partition Table）：64字节，包含硬盘上最多四个主分区的分区信息。
>    - **签名**（Signature）：最后2字节，通常是0x55和0xAA，用于标识MBR的有效性。
> 3. **MBR的作用**：
>    - **引导系统**：在计算机启动时，BIOS加载MBR并执行其中的引导代码，引导代码负责定位和加载引导加载程序（如GRUB）。
>    - **管理分区**：MBR中的分区表记录了硬盘上各个分区的起始位置和大小。
>
> 
>
> 以上GPT 一般来说 只需要知道MBR确定了  文件的信息 以及合法性即可





## 数学视角的操作系统

### 程序的正确性 & 数学严格

依然是从状态机入手，程序是一种“数学严格”的对象

**本质上：程序 = 初始状态 + 迁移函数**
$$
f(s)=s′
$$
程序运行的每一步逻辑修改 都可以看作是执行特定函数之后的变化

ps:jyy老师此处的引入论述非常有意思

> 人类本身不擅长数学严格
>
> 于是创建了程序  程序本身是数学严格的
>
> 程序辅助人类进行数学严格的工作
>
> 使人类世界更好实现数学严格的需求
>
> 
>
> 也因此 初学者对“机器严格”普遍不太适应
>
> 他们并不擅长程序的编写 对程序的行为没有100%的掌控  

相似的 我们也可以使用证明数学正确性的方法来证明**程序的正确性** 不在此处展开说明

- 暴力枚举
- 写出证明



### 操作系统建模

以两个视角看待操作系统：

应用视角（自顶向下）：**系统调用**服务的提供者

> 操作系统 = 对象 + API
>
> 应用通过 syscall访问操作系统

机器视角（自底向上）：运行的一个程序

> 从硬件的视角看 所有的程序本质上都是一样的

在之前的分析中说到 **程序本身就是一个状态机**。而操作系统本身也是一个状态机（操作系统本身也是一个程序），程序是运行在操作系统上的。在这个视角下，`操作系统 = 状态机的管理者`

而程序的行为也已分析过，其本质上就是数据的IO。站在系统调用的角度上，即是提供给程序 **Read  & Write** 的API。但是仅此还不够，操作系统作为一个管理者，具有创建或销毁指定的线程的能力。在多核的情况下，也具有**上下文切换，调度**等能力



当以一个状态机的视角来理解操作系统。无非就分为三点：**状态、初始状态、迁移**

- 初始状态：仅有一个"main"状态机，此状态机就是操作系统这一程序本身的初始状态
- 状态：运行多个不同执行阶段的程序
- 迁移：选择一个状态机进行程序的运行（其实就是调度）



但是在计算机系统运行中，存在不确定性

- **调度**：操作系统会根据某种策略自行选择下次执行的状态机。

- **IO**：执行程序时的输入不确定

但是如果**程序的正确性**得到了保证。我们就可以模拟出程序运行时所有的不确定性情况，并将其构建为一张图（模型）。图中的每一个节点，记载此时操作系统的状态。每一边，记载到达此状态的流程（a -> b）。而我们更可以利用BFS等算法，就可以轻松获得状态机到达某个状态的路线（情况 & 缘由）。

> 太妙了

按照这一思路，我们理论上可以创建任何操作系统的模型。

| 模块   | 系统调用       | 行为                           |
| ------ | -------------- | ------------------------------ |
| 基础   | **choose(xs)** | 返回一个 xs 中的随机的选择     |
| 基础   | **write(s)**   | 向调试终端输出字符串 s         |
| 并发   | **spawn(fn)**  | 创建从 fn 开始执行的线程       |
| 并发   | **sched()**    | 切换到随机的线程/进程执行      |
| 虚拟化 | fork()         | 创建当前状态机的完整复制       |
| 持久化 | bread(k)       | 读取虚拟磁盘块 k 的数据        |
| 持久化 | bwrite(k, v)   | 向虚拟磁盘块 k 写入数据 v      |
| 持久化 | sync()         | 将所有向虚拟磁盘的数据写入落盘 |
| 持久化 | crash()        | 模拟系统崩溃                   |
