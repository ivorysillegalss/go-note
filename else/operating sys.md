operating sys

瞎记乱学

### 应用层面

所有的程序本身只有数据，而在程序运行中只有数据的处理。程序本身是没有能力打开或关闭的 需要依赖于系统调用(system call)

> 在操作系统的上下文中，程序本身是由数据和代码组成的静态实体，它只有在被加载和执行时才会成为一个动态的进程。程序本身没有能力自行打开或关闭，而是依赖于操作系统提供的系统调用（system call）来执行这些操作。

所有的程序都可以理解为一个黑盒子 sandbox

所有的软件都只是设计了对应数据的IO 

窗口 浏览器等页面也是同理 软件本身并不具备打开窗口的能力

而是各操作系统上提供了一个**任务管理器** 此任务管理器提供对应的api给各软件

当某个软件需要创建新窗口的时候 他就会将创建对应窗口的参数传给任务管理器

任务管理器将此创建新的窗口并同统一对其进行管理



> **任务管理器到底算是操作系统的一部分还是软件的一部分？**
>
> 如果站在软件上看 它也是IO对应的数据 并将其进行处理 只是它所output的方式是图形化界面而已
>
> 如果是操作系统 它通过syscall获取对某些系统资源（CPU占用率）的访问权限。也实现了属于自身的系统调用 （它可以新建 & 结束某些其他进程）
>
> 综上，虽然应用管理器本身只是一个用户空间的应用程序，但他通过与操作系统内核的紧密交互实现了类似“系统调用的功能”
>
> 
>
> **上述只是本人一些思考**



> 万物皆是状态机

如上所说 所有的程序都是无非都是数据的处理 同时也是状态的切换。

任何一个程序 包括从高级语言到c语言到汇编

基本上都是围绕着状态的切换

从这一角度上看 c语言中的编译 无非就是讲状态切换的逻辑转换描述方式 罢了



M1 打印进程树 pstreehttps://jyywiki.cn/OS/2024/labs/M1.md

> Everything is file

首先展示pstree运行效果

![image-20240727154511627](.\images\image-20240727154511627.png)

此命令将正在运行的进程与其父进程方式 以树的方式输出



根据上方的思路，我们可以设想所有的进程及其信息，包括其窗口化的信息等。也许会统一存储在某个文件当中

在linux当中，存储在`/proc`目录下，进入目录可以看到许多以数字为编号的文件夹。可以料想到每一个编号其实就是每一个进程的编号（PID）。

下方使用linux中ps命令查看 正在运行的进程



![image-20240727154202464](.\images\image-20240108152543702.png)

然后在proc目录下进入对应2237目录 vim打开status文件 （此文件存储进程的名字）

此处的PPID即是对应进程的父进程

![image-20240727154332631](.\images\image-20240727154332631.png)

根据上方目录可知道所有进程的父进程都是systemd 且其进程PID为1

进入对应目录可发现它的父ID是0



综合以上的信息，我们可以用proc来记录，获取每一个进程的运行状态和他的父进程。之后只需要以递归，遍历树的方式将其组织输出出来就好了。