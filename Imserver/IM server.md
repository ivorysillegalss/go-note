# IM server

**此md记录学习im相关的一些笔记**



确保 QOS2 + 时序性

- 可达性

- 准确性

- 时序性 消息按照时间顺序排列

关于字符流和字节流：

字符流可读 但是其效率不如字节流 传输的时候不需要转化

字节流在传输的时候需要进行序列化等操作 但是其传输效率高

小公司（几百QPS）一般使用的是字符流多

但是大规模项目一般使用字节流 且protobuf





### TCP & UDP

TCP面向**连接**协议，可分为长连接或短连接。

UDP面向**消息**协议，对于每一条信息都将创建一次UDP连接。

TCP在经过三次握手之后，确认连接的建立。再将信息发送出去。并在信息确认发送出去之后返回类似ACK的信息。表示信息成功传输

UDP的每一次连接都是对于信息而言的。每一条信息都是由发送方，发送出去就不管了。并且没有相比之下精密的握手等规定。

相比之下：

UDP在弱网环境下表现更优，由于特性决定了它的消息请求体相比之下会更小。而弱网的环境下，可以将UDP原有协议，进行一定程度上的包装和自定义。从而使他更加适合IM的使用环境。



IM中，数据通讯层无论用的是UDP还是TCP协议，都同样需要消息送达保证（即QoS）机制，原因在于IM的通信是A端-Server-B端的3方通信，而非传统C/S或B/S这种2方通信





### 关于消息的一致性思考

> 设两人一对一聊天，发送方A依次发出了msg1、msg2、msg3三条消息给接收方B，这三条消息该怎么保证显示时序的一致性（发送与显示的顺序一致）？ 我们知道，发送方A依次发出的msg1、msg2、msg3三条消息，到底服务端后，再由服务端中转发出时，这个顺序由于多线程的网络的问题，是有可能乱序的。 
>
> 会出现与发出时的消息时序不一致问题（收到的消息顺序是：msg3、msg1、msg2）。 不过，实际上一对一聊天的两个人，并不需要全局消息时序的一致（因为聊天只在两人的同一会话在发生），只需要对于同一个发送方A，发给B的消息时序一致就行了。 常见优化方案，在A往B发出的消息中，加上发送方A本地的一个绝对时序（比如本机时间戳），来表示接收方B的展现时序。 那么当接收方B收到消息后，即使极端情况下消息可能存在乱序到达，但因为这个乱序的时间差对于普通用户来说体感是很短的，在UI展现层按照消息中自带的绝对时序排个序后再显示，用户其实是没有太多感知的。

上述的问题描述的是在**点对点聊天中**，消息的显示顺序和发送顺序的一致性（发送的过程中会因**多线程or网络延迟**等多方面原因有可能导致消息的乱序）。

对此场景下，可以在每条聊天信息中都附加一个标记（时间戳）。并根据此时间戳重新排序信息。

但是在此之中也会存在几个问题，譬如说，排序本身的效率不是很高。如何定义一个合适的时间段（一个合适的窗口）。并将在此时间段内的如何排序呢？

换句话来说，也就是。假设现在为了确保时序性，需要如上方解法采用一个MQ或其他容器来存储其中的信息。

- 但是如何规定这个容器的大小呢？ （一个容器一般情况下，最多存多少数据）

- 在消息间延迟低于什么值的时候，将值存到容器当中呢？（将延迟为多少的数据存入容器）

但是也许这些问题是根据IM实际使用场景所定义的，没有准确或否的答案。只有相关的优化方法。



> ### User
>
> 那么在这种情况下 是不是需要设计消息排序的时间段 规定一个进行排序的延迟范围 或是有其他更优的排序解法 并且当信息量很大的时候 这一个排序的时间成本也是很高的
>
> 
>
> ### ChatGPT
>
> 确实，当消息量增大或网络状况不稳定时，依靠时间戳进行消息排序可能会带来一些额外的挑战和考虑。以下是几种改进的方法和策略，以及如何处理大量消息时的排序效率问题：
>
> #### 设计消息排序的时间窗口
>
> 1. **定义时间窗口**：
>    - 可以设定一个时间窗口，允许在这个窗口期内接收的消息被缓存并排序。这个窗口可以是几秒钟，也可以根据网络延迟的实际情况进行调整。
>    - 时间窗口的目的是在不影响用户体验的前提下，给予系统足够的时间来接收和排序可能存在的乱序消息。
> 2. **动态调整**：
>    - 根据实际的网络状况和历史数据，动态调整时间窗口的大小。例如，如果检测到消息的平均延迟增加，可以相应地增加窗口大小。
>
> #### 排序算法优化
>
> - 高效的排序算法
>
>   ：
>
>   - 对于大量的消息排序，可以使用更高效的排序算法，比如快速排序、归并排序等，这些算法在最坏的情况下也能提供较好的性能。
>   - 在软件设计中，可以采用优先队列（例如使用二叉堆实现）来管理这些消息，优先队列可以高效地插入新消息并取出最早的消息。
>
> #### 采用序列号而非时间戳
>
> - 序列号系统
>
>   ：
>
>   - 另一个选择是使用一个增长的序列号而非时间戳。每发送一条消息，序列号增加。这样，即便两个系统的时钟不同步，消息的顺序也能被正确处理。
>   - 这要求发送方在每次会话开始时同步序列号，确保消息的连贯性。
>
> #### 实时同步和校正机制
>
> - **时钟同步**：
>   - 如果继续使用时间戳，那么可以在客户端之间实施一种时钟同步机制，如NTP（网络时间协议），来减少时间差异带来的影响。
> - **消息确认和重发机制**：
>   - 设计一个机制来确认消息的接收状态，并在未确认的情况下进行消息重发。这不仅帮助保持消息顺序，还确保了消息的可靠传输。
>
> #### 总结
>
> 在设计这样的系统时，关键在于找到实现效率和用户体验之间的平衡。选择合适的时间窗口、优化排序算法、使用序列号和实施时间同步策略都是提高系统性能和用户满意度的有效方法。在实际应用中，可以根据特定的需求和条件选择最适合的策略。





### 全局时序性 & 单点时序性

确实，全局时序性和单个群聊的时序性在概念和实际应用中有所不同。了解这两者的差异对于设计聊天系统尤为重要，特别是在考虑消息的一致性和用户体验时。

#### 全局时序性（Global Ordering）

全局时序性是指在一个系统中，所有消息都遵循一个统一的、全系统范围内的时序。这种时序保证了来自不同发送者的所有消息都按照一定的全局顺序被处理和接收。全局时序性常见于需要严格顺序处理的系统，比如金融交易系统，其中交易的顺序可能影响最终结果。

- **应用场景**：例如，一个大型的社交平台可能需要维护不同聊天群组之间消息的全局时序，以便于进行系统范围内的搜索、审核或其他全局操作。
- **挑战**：实现全局时序性通常要求复杂的时间同步机制和一致性协议，可能涉及较高的技术复杂度和资源消耗。

##### 单个群聊的时序性（Local Ordering）

单个群聊的时序性指的是在同一个聊天群组内，确保消息按发送顺序被所有成员看到的一致性。这种时序性只关注单一聊天环境中的消息顺序，不涉及跨群组或系统的消息顺序。

- **应用场景**：任何群聊系统，如WhatsApp、Telegram、企业内部通讯工具等。用户期望在同一个聊天群组内，无论是哪个成员发送的消息，都应该按照发送的顺序展现。
- **实现**：通常通过给每个消息加上时间戳或序列号来实现。只要群组内的成员接收和处理消息的机制一致，就可以保证群内消息的时序性。

##### 关键差异

- **范围与复杂性**：全局时序性需要在整个系统的层面上维护消息顺序，技术实现更为复杂；而单个群聊的时序性只关注局部环境，实现相对简单。
- **性能考虑**：全局时序性可能因为涉及更广泛的数据同步和一致性检查，对系统性能有较大影响；单个群聊的时序性对性能的影响较小，更容易优化。
- **用户体验**：从用户的角度看，群聊的时序性直接影响到他们的交流体验，而全局时序性通常是后台操作，用户不易察觉。